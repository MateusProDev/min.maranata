{"version":3,"file":"remark-slate.cjs.production.min.js","sources":["../src/ast-types.ts","../src/deserialize.ts","../src/serialize.ts","../src/plugin.ts"],"sourcesContent":["export interface NodeTypes {\n  paragraph: 'paragraph';\n  block_quote: 'block_quote';\n  code_block: 'code_block';\n  link: 'link';\n  ul_list: 'ul_list';\n  ol_list: 'ol_list';\n  listItem: 'list_item';\n  heading: {\n    1: 'heading_one';\n    2: 'heading_two';\n    3: 'heading_three';\n    4: 'heading_four';\n    5: 'heading_five';\n    6: 'heading_six';\n  };\n  emphasis_mark: 'italic';\n  strong_mark: 'bold';\n  delete_mark: 'strikeThrough';\n  inline_code_mark: 'code';\n  thematic_break: 'thematic_break';\n  image: 'image';\n}\n\nexport type MdastNodeType =\n  | 'paragraph'\n  | 'heading'\n  | 'list'\n  | 'listItem'\n  | 'link'\n  | 'image'\n  | 'blockquote'\n  | 'code'\n  | 'html'\n  | 'emphasis'\n  | 'strong'\n  | 'delete'\n  | 'inlineCode'\n  | 'thematicBreak'\n  | 'text';\n\nexport const defaultNodeTypes: NodeTypes = {\n  paragraph: 'paragraph',\n  block_quote: 'block_quote',\n  code_block: 'code_block',\n  link: 'link',\n  ul_list: 'ul_list',\n  ol_list: 'ol_list',\n  listItem: 'list_item',\n  heading: {\n    1: 'heading_one',\n    2: 'heading_two',\n    3: 'heading_three',\n    4: 'heading_four',\n    5: 'heading_five',\n    6: 'heading_six',\n  },\n  emphasis_mark: 'italic',\n  strong_mark: 'bold',\n  delete_mark: 'strikeThrough',\n  inline_code_mark: 'code',\n  thematic_break: 'thematic_break',\n  image: 'image',\n};\n\nexport interface LeafType {\n  text: string;\n  strikeThrough?: boolean;\n  bold?: boolean;\n  italic?: boolean;\n  code?: boolean;\n  parentType?: string;\n}\n\nexport interface BlockType {\n  type: string;\n  parentType?: string;\n  link?: string;\n  caption?: string;\n  language?: string;\n  break?: boolean;\n  children: Array<BlockType | LeafType>;\n}\n\nexport interface InputNodeTypes {\n  paragraph: string;\n  block_quote: string;\n  code_block: string;\n  link: string;\n  ul_list: string;\n  ol_list: string;\n  listItem: string;\n  heading: {\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n  };\n  emphasis_mark: string;\n  strong_mark: string;\n  delete_mark: string;\n  inline_code_mark: string;\n  thematic_break: string;\n  image: string;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: RecursivePartial<T[P]>;\n};\n\nexport interface OptionType<T extends InputNodeTypes = InputNodeTypes> {\n  nodeTypes?: RecursivePartial<T>;\n  linkDestinationKey?: string;\n  imageSourceKey?: string;\n  imageCaptionKey?: string;\n}\n\nexport interface MdastNode {\n  type?: MdastNodeType;\n  ordered?: boolean;\n  value?: string;\n  text?: string;\n  children?: Array<MdastNode>;\n  depth?: 1 | 2 | 3 | 4 | 5 | 6;\n  url?: string;\n  alt?: string;\n  lang?: string;\n  // mdast metadata\n  position?: any;\n  spread?: any;\n  checked?: any;\n  indent?: any;\n}\n\nexport type TextNode = { text?: string | undefined };\n\nexport type CodeBlockNode<T extends InputNodeTypes> = {\n  type: T['code_block'];\n  language: string | undefined;\n  children: Array<TextNode>;\n};\n\nexport type HeadingNode<T extends InputNodeTypes> = {\n  type:\n    | T['heading'][1]\n    | T['heading'][2]\n    | T['heading'][3]\n    | T['heading'][4]\n    | T['heading'][5]\n    | T['heading'][6];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ListNode<T extends InputNodeTypes> = {\n  type: T['ol_list'] | T['ul_list'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ListItemNode<T extends InputNodeTypes> = {\n  type: T['listItem'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ParagraphNode<T extends InputNodeTypes> = {\n  type: T['paragraph'];\n  break?: true;\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type LinkNode<T extends InputNodeTypes> = {\n  type: T['link'];\n  children: Array<DeserializedNode<T>>;\n  [urlKey: string]: string | undefined | Array<DeserializedNode<T>>;\n};\n\nexport type ImageNode<T extends InputNodeTypes> = {\n  type: T['image'];\n  children: Array<DeserializedNode<T>>;\n  [sourceOrCaptionKey: string]: string | undefined | Array<DeserializedNode<T>>;\n};\n\nexport type BlockQuoteNode<T extends InputNodeTypes> = {\n  type: T['block_quote'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type InlineCodeMarkNode<T extends InputNodeTypes> = {\n  type: T['inline_code_mark'];\n  children: Array<TextNode>;\n  language: string | undefined;\n};\n\nexport type ThematicBreakNode<T extends InputNodeTypes> = {\n  type: T['thematic_break'];\n  children: Array<DeserializedNode<T>>;\n};\n\nexport type ItalicNode<T extends InputNodeTypes> = {\n  [K in T['emphasis_mark']]: true;\n} & {\n  children: TextNode;\n};\n\nexport type BoldNode = {\n  bold: true;\n  children: TextNode;\n};\n\nexport type StrikeThoughNode = {\n  strikeThrough: true;\n  children: TextNode;\n};\n\nexport type InlineCodeNode = {\n  code: true;\n  text: string | undefined;\n};\n\nexport type DeserializedNode<T extends InputNodeTypes> =\n  | CodeBlockNode<T>\n  | HeadingNode<T>\n  | ListNode<T>\n  | ListItemNode<T>\n  | ParagraphNode<T>\n  | LinkNode<T>\n  | ImageNode<T>\n  | BlockQuoteNode<T>\n  | InlineCodeMarkNode<T>\n  | ThematicBreakNode<T>\n  | ItalicNode<T>\n  | BoldNode\n  | StrikeThoughNode\n  | InlineCodeNode\n  | TextNode;\n","import {\n  BlockQuoteNode,\n  CodeBlockNode,\n  defaultNodeTypes,\n  DeserializedNode,\n  HeadingNode,\n  ImageNode,\n  InputNodeTypes,\n  ItalicNode,\n  LinkNode,\n  ListItemNode,\n  ListNode,\n  MdastNode,\n  OptionType,\n  ParagraphNode,\n  TextNode,\n  ThematicBreakNode,\n} from './ast-types';\n\nexport default function deserialize<T extends InputNodeTypes>(\n  node: MdastNode,\n  opts?: OptionType<T>\n) {\n  const types = {\n    ...defaultNodeTypes,\n    ...opts?.nodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...opts?.nodeTypes?.heading,\n    },\n  };\n\n  const linkDestinationKey = opts?.linkDestinationKey ?? 'link';\n  const imageSourceKey = opts?.imageSourceKey ?? 'link';\n  const imageCaptionKey = opts?.imageCaptionKey ?? 'caption';\n\n  let children: Array<DeserializedNode<T>> = [{ text: '' }];\n\n  const nodeChildren = node.children;\n  if (nodeChildren && Array.isArray(nodeChildren) && nodeChildren.length > 0) {\n    children = nodeChildren.flatMap((c: MdastNode) =>\n      deserialize(\n        {\n          ...c,\n          ordered: node.ordered || false,\n        },\n        opts\n      )\n    );\n  }\n\n  switch (node.type) {\n    case 'heading':\n      return {\n        type: types.heading[node.depth || 1],\n        children,\n      } as HeadingNode<T>;\n    case 'list':\n      return {\n        type: node.ordered ? types.ol_list : types.ul_list,\n        children,\n      } as ListNode<T>;\n    case 'listItem':\n      return { type: types.listItem, children } as ListItemNode<T>;\n    case 'paragraph':\n      return { type: types.paragraph, children } as ParagraphNode<T>;\n    case 'link':\n      return {\n        type: types.link,\n        [linkDestinationKey]: node.url,\n        children,\n      } as LinkNode<T>;\n    case 'image':\n      return {\n        type: types.image,\n        children: [{ text: '' }],\n        [imageSourceKey]: node.url,\n        [imageCaptionKey]: node.alt,\n      } as ImageNode<T>;\n    case 'blockquote':\n      return { type: types.block_quote, children } as BlockQuoteNode<T>;\n    case 'code':\n      return {\n        type: types.code_block,\n        language: node.lang,\n        children: [{ text: node.value }],\n      } as CodeBlockNode<T>;\n\n    case 'html':\n      if (node.value?.includes('<br>')) {\n        return {\n          break: true,\n          type: types.paragraph,\n          children: [{ text: node.value?.replace(/<br>/g, '') || '' }],\n        } as ParagraphNode<T>;\n      }\n      return { type: 'paragraph', children: [{ text: node.value || '' }] };\n\n    case 'emphasis':\n      return {\n        [types.emphasis_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      } as unknown as ItalicNode<T>;\n    case 'strong':\n      return {\n        [types.strong_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      };\n    case 'delete':\n      return {\n        [types.delete_mark as string]: true,\n        ...forceLeafNode(children as Array<TextNode>),\n        ...persistLeafFormats(children as Array<MdastNode>),\n      };\n    case 'inlineCode':\n      return {\n        [types.inline_code_mark as string]: true,\n        text: node.value,\n        ...persistLeafFormats(children as Array<MdastNode>),\n      };\n    case 'thematicBreak':\n      return {\n        type: types.thematic_break,\n        children: [{ text: '' }],\n      } as ThematicBreakNode<T>;\n\n    case 'text':\n    default:\n      return { text: node.value || '' };\n  }\n}\n\nconst forceLeafNode = (children: Array<TextNode>) => ({\n  text: children.map((k) => k?.text).join(''),\n});\n\n// This function is will take any unknown keys, and bring them up a level\n// allowing leaf nodes to have many different formats at once\n// for example, bold and italic on the same node\nfunction persistLeafFormats(\n  children: Array<MdastNode>\n): Omit<MdastNode, 'children' | 'type' | 'text'> {\n  return children.reduce((acc, node) => {\n    (Object.keys(node) as Array<keyof MdastNode>).forEach(function (key) {\n      if (key === 'children' || key === 'type' || key === 'text') return;\n\n      acc[key] = node[key];\n    });\n\n    return acc;\n  }, {});\n}\n","import { BlockType, defaultNodeTypes, LeafType, NodeTypes } from './ast-types';\nimport escapeHtml from 'escape-html';\n\ninterface Options {\n  nodeTypes: NodeTypes;\n  listDepth?: number;\n  ignoreParagraphNewline?: boolean;\n}\n\nconst isLeafNode = (node: BlockType | LeafType): node is LeafType => {\n  return typeof (node as LeafType).text === 'string';\n};\n\nconst VOID_ELEMENTS: Array<keyof NodeTypes> = ['thematic_break', 'image'];\n\nconst BREAK_TAG = '<br>';\n\nexport default function serialize(\n  chunk: BlockType | LeafType,\n  opts: Options = { nodeTypes: defaultNodeTypes }\n) {\n  const {\n    nodeTypes: userNodeTypes = defaultNodeTypes,\n    ignoreParagraphNewline = false,\n    listDepth = 0,\n  } = opts;\n\n  let text = (chunk as LeafType).text || '';\n  let type = (chunk as BlockType).type || '';\n\n  const nodeTypes: NodeTypes = {\n    ...defaultNodeTypes,\n    ...userNodeTypes,\n    heading: {\n      ...defaultNodeTypes.heading,\n      ...userNodeTypes.heading,\n    },\n  };\n\n  const LIST_TYPES = [nodeTypes.ul_list, nodeTypes.ol_list];\n\n  let children = text;\n\n  if (!isLeafNode(chunk)) {\n    children = chunk.children\n      .map((c: BlockType | LeafType) => {\n        const isList = !isLeafNode(c)\n          ? (LIST_TYPES as string[]).includes(c.type || '')\n          : false;\n\n        const selfIsList = (LIST_TYPES as string[]).includes(chunk.type || '');\n\n        // Links can have the following shape\n        // In which case we don't want to surround\n        // with break tags\n        // {\n        //  type: 'paragraph',\n        //  children: [\n        //    { text: '' },\n        //    { type: 'link', children: [{ text: foo.com }]}\n        //    { text: '' }\n        //  ]\n        // }\n        let childrenHasLink = false;\n\n        if (!isLeafNode(chunk) && Array.isArray(chunk.children)) {\n          childrenHasLink = chunk.children.some(\n            (f) => !isLeafNode(f) && f.type === nodeTypes.link\n          );\n        }\n\n        return serialize(\n          { ...c, parentType: type },\n          {\n            nodeTypes,\n            // WOAH.\n            // what we're doing here is pretty tricky, it relates to the block below where\n            // we check for ignoreParagraphNewline and set type to paragraph.\n            // We want to strip out empty paragraphs sometimes, but other times we don't.\n            // If we're the descendant of a list, we know we don't want a bunch\n            // of whitespace. If we're parallel to a link we also don't want\n            // to respect neighboring paragraphs\n            ignoreParagraphNewline:\n              (ignoreParagraphNewline ||\n                isList ||\n                selfIsList ||\n                childrenHasLink) &&\n              // if we have c.break, never ignore empty paragraph new line\n              !(c as BlockType).break,\n\n            // track depth of nested lists so we can add proper spacing\n            listDepth: (LIST_TYPES as string[]).includes(\n              (c as BlockType).type || ''\n            )\n              ? listDepth + 1\n              : listDepth,\n          }\n        );\n      })\n      .join('');\n  }\n\n  // This is pretty fragile code, check the long comment where we iterate over children\n  if (\n    !ignoreParagraphNewline &&\n    (text === '' || text === '\\n') &&\n    chunk.parentType === nodeTypes.paragraph\n  ) {\n    type = nodeTypes.paragraph;\n    children = BREAK_TAG;\n  }\n\n  if (children === '' && !VOID_ELEMENTS.find((k) => nodeTypes[k] === type))\n    return;\n\n  // Never allow decorating break tags with rich text formatting,\n  // this can malform generated markdown\n  // Also ensure we're only ever applying text formatting to leaf node\n  // level chunks, otherwise we can end up in a situation where\n  // we try applying formatting like to a node like this:\n  // \"Text foo bar **baz**\" resulting in \"**Text foo bar **baz****\"\n  // which is invalid markup and can mess everything up\n  if (children !== BREAK_TAG && isLeafNode(chunk)) {\n    if (chunk.strikeThrough && chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '~~***');\n    } else if (chunk.bold && chunk.italic) {\n      children = retainWhitespaceAndFormat(children, '***');\n    } else {\n      if (chunk.bold) {\n        children = retainWhitespaceAndFormat(children, '**');\n      }\n\n      if (chunk.italic) {\n        children = retainWhitespaceAndFormat(children, '_');\n      }\n\n      if (chunk.strikeThrough) {\n        children = retainWhitespaceAndFormat(children, '~~');\n      }\n\n      if (chunk.code) {\n        children = retainWhitespaceAndFormat(children, '`');\n      }\n    }\n  }\n\n  switch (type) {\n    case nodeTypes.heading[1]:\n      return `# ${children}\\n`;\n    case nodeTypes.heading[2]:\n      return `## ${children}\\n`;\n    case nodeTypes.heading[3]:\n      return `### ${children}\\n`;\n    case nodeTypes.heading[4]:\n      return `#### ${children}\\n`;\n    case nodeTypes.heading[5]:\n      return `##### ${children}\\n`;\n    case nodeTypes.heading[6]:\n      return `###### ${children}\\n`;\n\n    case nodeTypes.block_quote:\n      // For some reason, marked is parsing blockquotes w/ one new line\n      // as contiued blockquotes, so adding two new lines ensures that doesn't\n      // happen\n      return `> ${children}\\n\\n`;\n\n    case nodeTypes.code_block:\n      return `\\`\\`\\`${\n        (chunk as BlockType).language || ''\n      }\\n${children}\\n\\`\\`\\`\\n`;\n\n    case nodeTypes.link:\n      return `[${children}](${(chunk as BlockType).link || ''})`;\n    case nodeTypes.image:\n      return `![${(chunk as BlockType).caption}](${\n        (chunk as BlockType).link || ''\n      })`;\n\n    case nodeTypes.ul_list:\n    case nodeTypes.ol_list:\n      return `\\n${children}\\n`;\n\n    case nodeTypes.listItem:\n      const isOL = chunk && chunk.parentType === nodeTypes.ol_list;\n      const treatAsLeaf =\n        (chunk as BlockType).children.length === 1 &&\n        isLeafNode((chunk as BlockType).children[0]);\n\n      let spacer = '';\n      for (let k = 0; listDepth > k; k++) {\n        if (isOL) {\n          // https://github.com/remarkjs/remark-react/issues/65\n          spacer += '   ';\n        } else {\n          spacer += '  ';\n        }\n      }\n      return `${spacer}${isOL ? '1.' : '-'} ${children}${\n        treatAsLeaf ? '\\n' : ''\n      }`;\n\n    case nodeTypes.paragraph:\n      return `${children}\\n`;\n\n    case nodeTypes.thematic_break:\n      return `---\\n`;\n\n    default:\n      return escapeHtml(children);\n  }\n}\n\n// This function handles the case of a string like this: \"   foo   \"\n// Where it would be invalid markdown to generate this: \"**   foo   **\"\n// We instead, want to trim the whitespace out, apply formatting, and then\n// bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\nfunction retainWhitespaceAndFormat(string: string, format: string) {\n  // we keep this for a comparison later\n  const frozenString = string.trim();\n\n  // children will be mutated\n  let children = frozenString;\n\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const fullFormat = `${format}${children}${reverseStr(format)}`;\n\n  // This conditions accounts for no whitespace in our string\n  // if we don't have any, we can return early.\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n\n  // if we do have whitespace, let's add our formatting around our trimmed string\n  // We reverse the right side formatting, to properly handle bold/italic and strikeThrough\n  // formats, so we can create ~~***FooBar***~~\n  const formattedString = format + children + reverseStr(format);\n\n  // and replace the non-whitespace content of the string\n  return string.replace(frozenString, formattedString);\n}\n\nconst reverseStr = (string: string) => string.split('').reverse().join('');\n","import { MdastNode, OptionType } from './ast-types';\nimport transform from './deserialize';\n\nexport default function plugin(opts?: OptionType) {\n  const compiler = (node: { children: Array<MdastNode> }) => {\n    return node.children.map((c) => transform(c, opts));\n  };\n\n  // @ts-ignore\n  this.Compiler = compiler;\n}\n"],"names":["defaultNodeTypes","paragraph","block_quote","code_block","link","ul_list","ol_list","listItem","heading","emphasis_mark","strong_mark","delete_mark","inline_code_mark","thematic_break","image","deserialize","node","opts","types","nodeTypes","_opts$nodeTypes","linkDestinationKey","imageSourceKey","imageCaptionKey","children","text","nodeChildren","Array","isArray","length","flatMap","c","ordered","type","depth","url","alt","language","lang","value","_node$value","includes","replace","forceLeafNode","persistLeafFormats","map","k","join","reduce","acc","Object","keys","forEach","key","isLeafNode","VOID_ELEMENTS","retainWhitespaceAndFormat","string","format","frozenString","trim","fullFormat","reverseStr","formattedString","split","reverse","Compiler","transform","serialize","chunk","userNodeTypes","ignoreParagraphNewline","listDepth","LIST_TYPES","isList","selfIsList","childrenHasLink","some","f","parentType","find","strikeThrough","bold","italic","code","caption","isOL","treatAsLeaf","spacer","escapeHtml"],"mappings":"yWAyCaA,EAA8B,CACzCC,UAAW,YACXC,YAAa,cACbC,WAAY,aACZC,KAAM,OACNC,QAAS,UACTC,QAAS,UACTC,SAAU,YACVC,QAAS,GACJ,gBACA,gBACA,kBACA,iBACA,iBACA,eAELC,cAAe,SACfC,YAAa,OACbC,YAAa,gBACbC,iBAAkB,OAClBC,eAAgB,iBAChBC,MAAO,kBC3CeC,EACtBC,EACAC,6BAEMC,OACDlB,EACAiB,MAAAA,SAAAA,EAAME,WACTX,aACKR,EAAiBQ,QACjBS,MAAAA,aAAAA,EAAME,8BAANC,EAAiBZ,WAIlBa,YAAqBJ,MAAAA,SAAAA,EAAMI,kCAAsB,OACjDC,YAAiBL,MAAAA,SAAAA,EAAMK,8BAAkB,OACzCC,YAAkBN,MAAAA,SAAAA,EAAMM,+BAAmB,UAE7CC,EAAuC,CAAC,CAAEC,KAAM,KAE9CC,EAAeV,EAAKQ,gBACtBE,GAAgBC,MAAMC,QAAQF,IAAiBA,EAAaG,OAAS,IACvEL,EAAWE,EAAaI,SAAQ,SAACC,UAC/BhB,OAEOgB,GACHC,QAAShB,EAAKgB,UAAW,IAE3Bf,OAKED,EAAKiB,UACN,gBACI,CACLA,KAAMf,EAAMV,QAAQQ,EAAKkB,OAAS,GAClCV,SAAAA,OAEC,aACI,CACLS,KAAMjB,EAAKgB,QAAUd,EAAMZ,QAAUY,EAAMb,QAC3CmB,SAAAA,OAEC,iBACI,CAAES,KAAMf,EAAMX,SAAUiB,SAAAA,OAC5B,kBACI,CAAES,KAAMf,EAAMjB,UAAWuB,SAAAA,OAC7B,iBAEDS,KAAMf,EAAMd,OACXiB,GAAqBL,EAAKmB,MAC3BX,SAAAA,QAEC,kBAEDS,KAAMf,EAAMJ,MACZU,SAAU,CAAC,CAAEC,KAAM,OAClBH,GAAiBN,EAAKmB,MACtBZ,GAAkBP,EAAKoB,UAEvB,mBACI,CAAEH,KAAMf,EAAMhB,YAAasB,SAAAA,OAC/B,aACI,CACLS,KAAMf,EAAMf,WACZkC,SAAUrB,EAAKsB,KACfd,SAAU,CAAC,CAAEC,KAAMT,EAAKuB,aAGvB,8BACCvB,EAAKuB,oBAALC,EAAYC,SAAS,QAChB,QACE,EACPR,KAAMf,EAAMjB,UACZuB,SAAU,CAAC,CAAEC,gBAAMT,EAAKuB,4BAAOG,QAAQ,QAAS,MAAO,MAGpD,CAAET,KAAM,YAAaT,SAAU,CAAC,CAAEC,KAAMT,EAAKuB,OAAS,UAE1D,4BAEArB,EAAMT,gBAA0B,KAC9BkC,EAAcnB,GACdoB,EAAmBpB,QAErB,0BAEAN,EAAMR,cAAwB,KAC5BiC,EAAcnB,GACdoB,EAAmBpB,QAErB,0BAEAN,EAAMP,cAAwB,KAC5BgC,EAAcnB,GACdoB,EAAmBpB,QAErB,8BAEAN,EAAMN,mBAA6B,IACpCa,KAAMT,EAAKuB,SACRK,EAAmBpB,QAErB,sBACI,CACLS,KAAMf,EAAML,eACZW,SAAU,CAAC,CAAEC,KAAM,UAGlB,qBAEI,CAAEA,KAAMT,EAAKuB,OAAS,KAInC,IAAMI,EAAgB,SAACnB,SAA+B,CACpDC,KAAMD,EAASqB,KAAI,SAACC,UAAMA,MAAAA,SAAAA,EAAGrB,QAAMsB,KAAK,MAM1C,SAASH,EACPpB,UAEOA,EAASwB,QAAO,SAACC,EAAKjC,UAC1BkC,OAAOC,KAAKnC,GAAiCoC,SAAQ,SAAUC,GAClD,aAARA,GAA8B,SAARA,GAA0B,SAARA,IAE5CJ,EAAII,GAAOrC,EAAKqC,OAGXJ,IACN,IC/IL,IAAMK,EAAa,SAACtC,SACwB,iBAA3BA,EAAkBS,MAG7B8B,EAAwC,CAAC,iBAAkB,SA2MjE,SAASC,EAA0BC,EAAgBC,OAE3CC,EAAeF,EAAOG,OAGxBpC,EAAWmC,EAITE,KAAgBH,EAASlC,EAAWsC,EAAWJ,MAIjDlC,EAASK,SAAW4B,EAAO5B,cACtBgC,MAMHE,EAAkBL,EAASlC,EAAWsC,EAAWJ,UAGhDD,EAAOf,QAAQiB,EAAcI,GAGtC,IAAMD,EAAa,SAACL,UAAmBA,EAAOO,MAAM,IAAIC,UAAUlB,KAAK,8BC/OxC9B,QAMxBiD,SALY,SAAClD,UACTA,EAAKQ,SAASqB,KAAI,SAACd,UAAMoC,EAAUpC,EAAGd,oFDYzBmD,EACtBC,EACApD,YAAAA,IAAAA,EAAgB,CAAEE,UAAWnB,UAMzBiB,EAHFE,UAAWmD,aAAgBtE,MAGzBiB,EAFFsD,uBAAAA,kBAEEtD,EADFuD,UAAAA,aAAY,IAGV/C,EAAQ4C,EAAmB5C,MAAQ,GACnCQ,EAAQoC,EAAoBpC,MAAQ,GAElCd,OACDnB,EACAsE,GACH9D,aACKR,EAAiBQ,QACjB8D,EAAc9D,WAIfiE,EAAa,CAACtD,EAAUd,QAASc,EAAUb,SAE7CkB,EAAWC,KAEV6B,EAAWe,KACd7C,EAAW6C,EAAM7C,SACdqB,KAAI,SAACd,OACE2C,GAAUpB,EAAWvB,IACtB0C,EAAwBhC,SAASV,EAAEE,MAAQ,IAG1C0C,EAAcF,EAAwBhC,SAAS4B,EAAMpC,MAAQ,IAa/D2C,GAAkB,SAEjBtB,EAAWe,IAAU1C,MAAMC,QAAQyC,EAAM7C,YAC5CoD,EAAkBP,EAAM7C,SAASqD,MAC/B,SAACC,UAAOxB,EAAWwB,IAAMA,EAAE7C,OAASd,EAAUf,SAI3CgE,OACArC,GAAGgD,WAAY9C,IACpB,CACEd,UAAAA,EAQAoD,wBACGA,GACCG,GACAC,GACAC,KAEA7C,QAGJyC,UAAYC,EAAwBhC,SACjCV,EAAgBE,MAAQ,IAEvBuC,EAAY,EACZA,OAITzB,KAAK,KAKPwB,GACS,KAAT9C,GAAwB,OAATA,GAChB4C,EAAMU,aAAe5D,EAAUlB,YAE/BgC,EAAOd,EAAUlB,UACjBuB,EA9Fc,QAiGC,KAAbA,GAAoB+B,EAAcyB,MAAK,SAAClC,UAAM3B,EAAU2B,KAAOb,YAjGnD,SA2GZT,GAA0B8B,EAAWe,KACnCA,EAAMY,eAAiBZ,EAAMa,MAAQb,EAAMc,OAC7C3D,EAAWgC,EAA0BhC,EAAU,SACtC6C,EAAMa,MAAQb,EAAMc,OAC7B3D,EAAWgC,EAA0BhC,EAAU,QAE3C6C,EAAMa,OACR1D,EAAWgC,EAA0BhC,EAAU,OAG7C6C,EAAMc,SACR3D,EAAWgC,EAA0BhC,EAAU,MAG7C6C,EAAMY,gBACRzD,EAAWgC,EAA0BhC,EAAU,OAG7C6C,EAAMe,OACR5D,EAAWgC,EAA0BhC,EAAU,QAK7CS,QACDd,EAAUX,QAAQ,cACTgB,YACTL,EAAUX,QAAQ,eACRgB,YACVL,EAAUX,QAAQ,gBACPgB,YACXL,EAAUX,QAAQ,iBACNgB,YACZL,EAAUX,QAAQ,kBACLgB,YACbL,EAAUX,QAAQ,mBACJgB,YAEdL,EAAUjB,uBAIDsB,cAETL,EAAUhB,wBAEVkE,EAAoBhC,UAAY,SAC9Bb,iBAEFL,EAAUf,eACFoB,QAAc6C,EAAoBjE,MAAQ,aAClDe,EAAUL,iBACAuD,EAAoBgB,cAC9BhB,EAAoBjE,MAAQ,aAG5Be,EAAUd,aACVc,EAAUb,mBACDkB,YAETL,EAAUZ,iBACP+E,EAAOjB,GAASA,EAAMU,aAAe5D,EAAUb,QAC/CiF,EACqC,IAAxClB,EAAoB7C,SAASK,QAC9ByB,EAAYe,EAAoB7C,SAAS,IAEvCgE,EAAS,GACJ1C,EAAI,EAAG0B,EAAY1B,EAAGA,IAG3B0C,GAFEF,EAEQ,MAEA,YAGJE,GAASF,EAAO,KAAO,SAAO9D,GACtC+D,EAAc,KAAO,SAGpBpE,EAAUlB,iBACHuB,YAEPL,EAAUN,4CAIN4E,EAAWjE"}